<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Microsoft Developer Studio">
<META HTTP-EQUIV="Content-Type" content="text/html; charset=gb_2312-80">
<TITLE>ISee图像读写插件开发文档</TITLE>
</HEAD>
<BODY>

<font face="宋体" size="4">




<table align="center" bgcolor="white" cols="1" width="760" >
<tr>
<td align="left"><img src="..\title.jpg"></td>
<td align="right"><a href="isnew_30.htm"><img src="..\prev.jpg" border=0></a> <a href="index.htm"><img src="..\index.jpg" border=0></a> <a href="isnew_32.htm"><img src="..\next.jpg" border=0></a></td>
</tr>
</table>
<hr width=760 align=center>



	
<table align="center" bgcolor="white" cols="1" width="760">

<tr align="center">
<td align="center">
<br><br><font face="宋体" size="5" color="#9999bb"><strong>ISeeMem系统设计原理</strong></font>
</td>
</tr>

<tr align="center">
<td align="center">
<br>
</td>
</tr>

<tr align="left">
<td align="left">
<br>
<strong>一、引言</strong><br><br>
在描述ISeeMem的设计原理之前，先简要介绍一些背景知识，这对于理解ISeeMem是很有帮助
的（注：以下内容只针对Windows系列平台）。<br>
<br>
现在流行的大多数操作系统中（包括Windows、Linux等等），内存管理的最基本单位是虚拟
内存页（Virtual Memory Page－简称内存页），虽然我们可以用malloc、new来分配任意尺
寸的内存块，但这些函数的最低层仍是对内存页进行操作，只不过这些函数封装的都比较好
，让我们感觉不到内存页的存在。<br>
<br>
在x86平台下，一个内存页的尺寸为4096字节，所以每次分配或释放内存页都必须以4096字节
为倍数增减。<br>
<br>
内存页共有三种“状态”属性，它们是：<br>
<br>
<font color="#00aa88">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、释放状态（free）<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、保留状态（reserved）<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、提交状态（committed）<br>
</font>
<br>
如果内存页处于释放或保留状态时，操作系统并不会为该页面分配任何实际的物理内存，只有
当页面被提交，并发生了实际的读写访问时，系统才会为其分配相应的内存。内存页还有三种
比较常用的“访问”属性，它们是：<br>
<br>
<font color="#00aa88">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、禁止访问（PAGE_NOACCESS）<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、只读（PAGE_READONLY）<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、读写（PAGE_READWRITE）<br>
</font>
<br>
一个处于释放状态或保留状态的内存页是被禁止访问的，任何试图读、写这些页面的操作都
将引发内存访问异常（令人心惊的GP对话框:）。一个处于提交状态的页面可以设置它的访问属性
为读写、只读、或禁止访问三种属性中的一种。<br>
<br>
以虚拟内存页的方式管理内存时，内存的分配和释放必须以“页”为单位，即使只想分配一个
字节的内存块，操作系统也会为其分配一整页的空间（4KB）。<br>
<br>
以上简要介绍了一些有关虚拟内存页的概念，这就算一个引子吧，因为下面的内容中将频繁的
使用这些概念，所以在此复述一遍。如果对这些内容不是很了解的话，建议查阅MSDN中有关虚
拟内存的资料。<br><br>
<br>
<br>
</td>
</tr>

<tr align="left">
<td align="left">
<strong>二、内存防护的核心技术</strong><br><br>
内存防护，这是一个即古老又现实的话题，在现今这个软件越做越大的时代里，软件的可靠性
显得非常重要。单从内存防护的角度来看，一块内存从被分配下来之后，就面临着很多种产生
错误的可能，请看下图：<br>
</td>
</tr>

<tr align="center">
<td align="center">
<br><img src="isnew_31_01.png"><br><br>
</td>
</tr>

<tr align="left">
<td align="left">
上图列举出的6种情况是较为常见的，这也是内存防护系统要重点解决的。下面我将逐条解释
ISeeMem是采用哪些技术来防范这些错误的。<br><br>
<br>
<em><strong><font color="#0088ff">A</font>、前溢出</strong></em><br>
_________________________________________<br>
<br>
前溢出的概念就是程序在向一块内存中写入数据时，将数据写到了该内存块的基地址前面的
内存中。在一些程序中，我们可能会使用 while() 循环倒着向内存块中写入数据，此时就很
容易发生前溢出的错误。ISeeMem为此准备了两级防护区来侦测此类错误。第一级是在内存块
的前面放置了一个8字节的溢出缓冲区，并在缓冲区中填充了一个标签值。如果前溢出的程度
比较轻（溢出2、3个字节），那么这一级防护区就可以侦测到此类错误（防护系统在释放这块
内存时会检查这个8字节的溢出缓冲区，如果它的内容被修改了，就会认为发生了前溢出）。<br>
<br>
如果前溢出比较严重，那么ISeeMem还设有第二级前溢出缓冲区。这个缓冲区是一个处于保留
状态的虚拟内存页。如果前溢出超出了一级缓冲区的长度（8字节）并继续向前溢出的时候，
操作系统会立即产生一个内存访问异常（被保留的虚拟内存页不允许被访问），向程序员指明
哪行代码具有前溢出行为。下图显示了两级前溢出缓冲区所处的位置：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src="isnew_31_02.png"><br>
两级的溢出防护基本可以杜绝大部分的前溢出问题，尤其是二级前溢出缓冲区，它带有一定的
强制性（如果你不修正这个问题，程序将无法继续向下运行），能够更精确的定位故障点。<br>
<br>
<br>
<em><strong><font color="#0088ff">B</font>、后溢出</strong></em><br>
_________________________________________<br>
<br>
后溢出的概念与前溢出相反，就是程序在向内存中写入数据时（从前向后写入），超出了内存
块的容量。这类问题更加常见，尤其是在向一个定长的数组中写入不定长的数据时最容易发生
此类故障。ISeeMem同样也采用了两级防护缓冲区。第一级是在内存块的尾部添加了一个8字节
的溢出缓冲区，缓冲区中填充一个标签值。如果发生了轻度的后溢出（少于等于8字节），那么
防护系统就会根据这一级缓冲区中的内容确定有后溢出故障发生。<br>
<br>
如果出现了严重的后溢出现象，那么报告该故障的责任就落到了第二级溢出缓冲区身上了。这个
缓冲区也是一个处于保留状态的虚拟内存页。如果后溢出操作超出了一级溢出缓冲区的长度（8
字节），那么系统将立即产生一个内存访问异常。从而暴露出有问题的代码。下图显示了两级后
溢出缓冲区所处的位置：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src="isnew_31_03.png"><br>
在这里，ISeeMem使用了一个技巧，就是第二级的后溢出缓冲区实际上是不存在的，它利用了下
一个内存块的第二级前溢出缓冲区，这可以有效减少虚拟地址的用量。另外，在一级后溢出缓冲
区与二级后溢出缓冲区之间可能会存在间隙。因为已分配内存块加上一级后溢出缓冲区的尺寸往
往并不能对齐到一个页边界上。这个间隙中的内存ISeeMem没有利用，其值无定义。<br>
<br>
<br>
<em><strong><font color="#0088ff">C</font>、非法写入操作</strong></em><br>
_________________________________________<br>
<br>
这类错误是最难发现的一种错误，当一个指针变量被错误的赋值后（俗称跑飞的指针），这种
问题最容易发生。比如指针应该指向 AAA 内存块并向其写入数据，但由于设计失误，指针指
向了 BBB 内存块，结果应该写入 AAA 内存的数据写入了 BBB 内存，但此时又没有发生溢出
错误，结果程序运行起来之后就会变得莫名其妙。<br>
<br>
ISeeMem解决此类问题的方法是为内存块设定只读属性。如果你的程序出现了上述的情况，那么
你可以将一些关键内存块设定为只读属性，这样，如果一个错误的指针指向这块内存，并试图
向其中写入数据，那么操作系统就会立即引发一个内存访问异常。从而暴露出是哪一块内存遭到
破坏，顺藤摸瓜就可以找到那个错误的指针。<br>
<br>
ISeeMem的这种能力在其它很多内存防护软件中是没有的，它对排查一些疑难杂症非常有用:)<br>
<br>
<br>
<em><strong><font color="#0088ff">D</font>、遗忘释放（内存泄漏）</strong></em><br>
_________________________________________<br>
<br>
这类问题比较常见，也很有“名气”。一般的解决方法是为每一块内存都申请一个信息节点，
然后用一个双向链表链接所有这些节点。如果释放一块内存，那么就从链表中将对应的节点
摘除。在程序退出时检查链表中是否还剩余了节点，如果剩余了节点，则说明有内存块没有
被程序释放，也就是说发生了内存泄漏。ISeeMem也采用了类似的方法，它为每一块防护系统
分配的内存都建立了一个信息节点，节点中记录了该内存的尺寸、访问属性、创建该内存的
源码所在文件、及所在行号等信息。如果在程序退出时仍有节点没有被摘除，则说明发生了
内存泄漏，这时ISeeMem就会根据节点中的数据报告是哪一行源代码分配的内存没有被释放，
从而使程序员能快速的找出引发问题的原因。<br>
<br>
VC++的防内存泄漏工作机制与ISeeMem类似，不过ISeeMem比它更健壮。ISeeMem没有把信息
节点与用户内存放在一起，而是将所有的节点数据都放在一个私有堆中管理。这样，用户内
存数据遭到破坏时不会影响到节点中的数据，这就使故障点的判断更加准确。<br>
<br>
<br>
<em><strong><font color="#0088ff">E</font>、引用未经初始化之内存块中的数据</strong></em><br>
_________________________________________<br>
<br>
此类问题也比较常见，比如你申请了一块内存用于存放一个结构（struct）的数据，结果你
没有初始化结构中的成员变量就引用了它们的值，这时就很容易导致问题。因为新申请的内存
内容很可能会是全0，而0在大多数程序中是有合法含义的，这就使问题不容易被发现。<br>
<br>
ISeeMem通过在新分配的内存中填写无用数据的方法来避免此类问题，也就是说通过ISeeMem
系统分配的内存块的初始内容不会是全0，ISeeMem会用一个特定值来填充它（当前这个填充
值是0xCD）。这样程序在引用这些值时会立即发现这是一个未经初始化的值。从而排除此类
问题。<br>
<br>
<br>
<em><strong><font color="#0088ff">F</font>、引用已释放之内存块中的数据</strong></em><br>
_________________________________________<br>
<br>
这类问题在大量使用链表、树等数据结构的软件中比较常见，因为它们经常会进行大量的内存
分配、释放操作。如果稍有不慎就会引用某个已被释放的内存块中的数据，而此时往往该地址
的内存区还未来得及被重分配，里面的数据还是原来的数据，这就会造成一个假象，程序因此
会在大多数情况下正常运行，直到某一个时刻突然崩溃。<br>
<br>
VC++对此的防御措施是向已释放的内存块中写入无用数据，而ISeeMem则具有先天防御此类故障
的能力，因为ISeeMem采用的是虚拟内存页的技术，对于那些已释放的内存ISeeMem会将其对应
的内存页设定为保留状态，任何对该内存的读、写操作都会引发内存访问异常，从而能更精确的
指出是那一行代码试图引用已释放内存中的数据。<br>
<br>
<br>
<br>
<strong>三、ISeeMem工作原理</strong><br><br>
ISeeMem是通过DLL的形式提供给使用者的，在宿主程序装载该DLL时，ISeeMem会做一些初始化
工作。首先，ISeeMem会向操作系统提出为其保留一块足够大的虚拟地址空间的申请（注意这里是
“保留”空间，操作系统并不会为其分配实际的内存），这块空间必须足够大，因为以后所有的
内存分配都将从该空间中获得（当前这个空间被设定为256MB，可以根据实际需要调整）。然后
ISeeMem会创建一个私有堆，用于存放内存块节点信息。最后ISeeMem会在这个私有堆中建立两个
双向链表，一个用于维护已分配内存块的节点，另一个用于维护空闲内存块的节点。<br>
<br>
初始化工作完成之后，宿主程序就可以利用ISeeMem提供的接口来分配或释放内存了（有关ISeeMem
的接口描述请参见下一章“ISeeMem系统使用说明”）。ISeeMem分配内存块的过程是先计算该内存
块将占用几个虚拟内存页，计算的方法是：<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1＋（8＋待分配内存尺寸＋8＋页尺寸－1）/页尺寸 ＝ 所需页数<br>
<br>
上式中前面的 1 是指二级前溢出缓冲区（1页），两个 8 是指一级前、后溢出缓冲区，二级后
溢出缓冲区（1页）没有出现在公式中，这是因为它利用了下一个相邻内存块的二级前溢出缓冲
区（参见上面有关后溢出防护技术中的说明）。计算出所需的页数之后，ISeeMem将在它的保留
区内分配（提交）所需页数－1的内存页，之所以减 1 ，是因为二级前溢出缓冲区页面必须处于
保留状态。如果分配成功的话，ISeeMem将初始化一级前、后溢出缓冲区的内存，并用废料字节
（0xCD）填充用户内存。<br>
<br>
在做以上工作的同时，ISeeMem还会在它的私有堆中分配一个信息节点，并在该节点中记录有关
这块内存的相关信息（包括它的基地址、所占页数、属性等）。之后，ISeeMem会将该节点插入
私有堆中的已分配内存节点链表。最后，ISeeMem的分配内存接口函数将返回用户内存的地址。
一个分配过程结束。<br>
<br>
当用户想释放一块由ISeeMem分配的内存块时，系统首先会在已分配内存节点链表中查找这块内存
的对应节点，并从链表中摘除这个节点。然后检查该内存块的一级前、后溢出缓冲区，如果发现
缓冲区内容被修改过，则向调试器的输出窗口显示提示信息。然后ISeeMem会将这块内存所对应的
所有虚拟内存页设置为保留状态，并将这些页的信息（起始页的地址、页数等）保存到私有堆的
空闲链表中，以备后用。<br>
<br>
在宿主程序退出时，ISeeMem将做一些清理工作。它首先会检查私有堆中的已分配内存链表，如果
该链表中还存在信息节点，就说明还有相应个数的内存块没有被程序释放（也就是发生了内存泄漏）
，此时ISeeMem就会向调试器的输出窗口显示有哪些内存块发生了内存泄漏，并指出分配这些内存
块的源码所处的位置。最后，ISeeMem还将显示在程序的整个运行期间共进行了多少次内存分配、
释放操作，以及瞬间最大内存需求量是多少。<br>
<br>
以上简要说明了ISeeMem的工作原理，其中有很多细节没有提及，比如ISeeMem是如何截获内存访问
异常的、空闲链表是如何管理的等等，这些信息可以通过阅读ISeeMem的源码获得。我相信，如果
你具有一定的 C 语言基础，并熟悉虚拟内存的有关知识，那么阅读这些代码是不会遇到任何困难的。
<br>
<br>
<br>
<br>
</td>
</tr>

<tr align="left">
<td align="left">
<strong>四、附注</strong><br><br>
* 有关ISeeMem的使用方法请参见下一章“ISeeMem系统使用说明”。<br>
* ISeeMem中已分配内存块节点链表的管理代码在 irw\iseemem\allolink.c 和 allolink.h 文件中。<br>
* ISeeMem中空闲内存链表的管理代码在 irw\iseemem\freelink.c 和 freelink.h 文件中。<br>
* irw\iseemem\iseemem.c 中是系统初始化和退出代码，以及系统接口函数实现代码。<br>
* irw\iseemem\iseemem.h 中是系统接口定义文件。<br>
<br>
</td>
</tr>



</table>





<hr width=760 align=center>
<table align="center" bgcolor="white" cols="1" width="760" >
<tr>
<td align="left"><font name="system">ISee Document NEW s/n: 031-20624</font></td>
<td align="right"><a href="isnew_30.htm"><img src="..\prev.jpg" border=0></a> <a href="index.htm"><img src="..\index.jpg" border=0></a> <a href="isnew_32.htm"><img src="..\next.jpg" border=0></a></td>
</tr>
</table>


	

</font>

</BODY>
</HTML>
