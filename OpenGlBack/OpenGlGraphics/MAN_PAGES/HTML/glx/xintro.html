<HTML>
<BODY>
<PRE>
     <STRONG>NAME</STRONG>
	  <STRONG>glXIntro</STRONG> - Introduction to OpenGL in the X window system


     <STRONG>OVERVIEW</STRONG>
	  OpenGL (called GL in other pages) is a high-performance 3D-
	  oriented renderer.  It is available in the X window system
	  through the GLX extension.  To determine whether the GLX
	  extension is supported by an X server, and if	so, what
	  version is supported,	call <STRONG>glXQueryExtension</STRONG> and
	  <STRONG>glXQueryVersion</STRONG>.

	  GLX extended servers make a subset of	their visuals
	  available for	OpenGL rendering.  Drawables created with
	  these	visuals	can also be rendered using the core X renderer
	  and with the renderer	of any other X extension that is
	  compatible with all core X visuals.

	  GLX extends drawables	with several buffers other than	the
	  standard color buffer.  These	buffers	include	back and
	  auxiliary color buffers, a depth buffer, a stencil buffer,
	  and a	color accumulation buffer.  Some or all	are included
	  in each X visual that	supports OpenGL.

	  To render using OpenGL into an X drawable, you must first
	  choose a visual that defines the required OpenGL buffers.
	  <STRONG>glXChooseVisual</STRONG> can be used to simplify selecting a
	  compatible visual.  If more control of the selection process
	  is required, use <STRONG>XGetVisualInfo</STRONG> and <STRONG>glXGetConfig</STRONG> to select
	  among	all the	available visuals.

	  Use the selected visual to create both a GLX context and an
	  X drawable.  GLX contexts are	created	with <STRONG>glXCreateContext</STRONG>,
	  and drawables	are created with either	<STRONG>XCreateWindow</STRONG> or
	  <STRONG>glXCreateGLXPixmap</STRONG>.  Finally,	bind the context and the
	  drawable together using <STRONG>glXMakeCurrent</STRONG>.  This
	  context/drawable pair	becomes	the current context and
	  current drawable, and	it is used by all OpenGL commands
	  until	<STRONG>glXMakeCurrent</STRONG> is called with different	arguments.

	  Both core X and OpenGL commands can be used to operate on
	  the current drawable.	 The X and OpenGL command streams are
	  not synchronized, however, except at explicitly created
	  boundaries generated by calling <STRONG>glXWaitGL</STRONG>, <STRONG>glXWaitX</STRONG>, <STRONG>XSync</STRONG>,
	  and <STRONG>glFlush</STRONG>.

     <STRONG>EXAMPLES</STRONG>
	  Below	is the minimum code required to	create an RGBA-format,
	  X window that's compatible with OpenGL and to	clear it to
	  yellow.  The code is correct,	but it does not	include	any
	  error	checking.  Return values <EM>dpy</EM>, <EM>vi</EM>, <EM>cx</EM>, <EM>cmap</EM>, and	<EM>win</EM>
	  should all be	tested.
	  #include &lt;GL/glx.h&gt; #include &lt;GL/gl.h&gt; #include &lt;unistd.h&gt;

	  static int attributeListSgl[]	= {	 GLX_RGBA,
	       GLX_RED_SIZE,   1, /*get	the deepest buffer with	1 red
	  bit*/	     GLX_GREEN_SIZE, 1,	     GLX_BLUE_SIZE,  1,
	       None };

	  static int attributeListDbl[]	= {	 GLX_RGBA,
	       GLX_DOUBLE_BUFFER, /*In case single buffering is	not
	  supported*/	   GLX_RED_SIZE,   1,	   GLX_GREEN_SIZE, 1,
	       GLX_BLUE_SIZE,  1,      None };


	  static Bool WaitForNotify(Display *d,	XEvent *e, char	*arg)
	  {
	      return (e-&gt;type == MapNotify) &amp;&amp; (e-&gt;xmap.window ==
	  (Window)arg);	}

	  int main(int argc, char **argv) {
	      Display *dpy;
	      XVisualInfo *vi;
	      Colormap cmap;
	      XSetWindowAttributes swa;
	      Window win;
	      GLXContext cx;
	      XEvent event;
	      int swap_flag = FALSE;


	      /* get a connection */
	      dpy = XOpenDisplay(0);

	      /* get an	appropriate visual */
	      vi = glXChooseVisual(dpy,	DefaultScreen(dpy),
	  attributeListSgl);
	      if (vi ==	NULL) {
		 vi = glXChooseVisual(dpy, DefaultScreen(dpy),
	  attributeListDbl);
		 swap_flag = TRUE;
	      }

	      /* create	a GLX context */
	      cx = glXCreateContext(dpy, vi, 0,	GL_TRUE);

	      /* create	a color	map */
	      cmap = XCreateColormap(dpy, RootWindow(dpy, vi-&gt;screen),
			    vi-&gt;visual,	AllocNone);

	      /* create	a window */
	      swa.colormap = cmap;
	      swa.border_pixel = 0;
	      swa.event_mask = StructureNotifyMask;
	      win = XCreateWindow(dpy, RootWindow(dpy, vi-&gt;screen), 0,
	  0, 100, 100,
				  0, vi-&gt;depth,	InputOutput, vi-
	  &gt;visual,
				  CWBorderPixel|CWColormap|CWEventMask,
	  &amp;swa);
	      XMapWindow(dpy, win);
	      XIfEvent(dpy, &amp;event, WaitForNotify, (char*)win);

	      /* connect the context to	the window */
	      glXMakeCurrent(dpy, win, cx);

	      /* clear the buffer */
	      glClearColor(1,1,0,1);
	      glClear(GL_COLOR_BUFFER_BIT);
	      glFlush();
	      if (swap_flag) glXSwapBuffers(dpy,win);

	      /* wait a	while */
	      sleep(10); }

     <STRONG>NOTES</STRONG>
	  A color map must be created and passed to <STRONG>XCreateWindow</STRONG>.
	  See the preceding example code.

	  A GLX	context	must be	created	and attached to	an X drawable
	  before OpenGL	commands can be	executed.  OpenGL commands
	  issued while no context/drawable pair	is current result in
	  undefined behavior.

	  Exposure events indicate that	<EM>all</EM> buffers associated with
	  the specified	window may be damaged and should be repainted.
	  Although certain buffers of some visuals on some systems may
	  never	require	repainting (the	depth buffer, for example), it
	  is incorrect to write	a program assuming that	these buffers
	  will not be damaged.

	  GLX commands manipulate XVisualInfo structures rather	than
	  pointers to visuals or visual	IDs.  XVisualInfo structures
	  contain <EM>visual</EM>, <EM>visualID</EM>, <EM>screen</EM>, and	<EM>depth</EM> elements,	as
	  well as other	X-specific information.

     <STRONG>USING</STRONG> <STRONG>GLX</STRONG> <STRONG>EXTENSIONS</STRONG>
	  All supported	GLX extensions will have a corresponding
	  definition in	glx.h and a token in the extension string
	  returned by <STRONG>glXQueryExtensionsString</STRONG>.	 For example, if the
	  <STRONG>EXT_visual_info</STRONG> extension is supported, then this token will
	  be defined in	glx.h and <STRONG>EXT_visual_info</STRONG> will appear in the
	  extension string returned by <STRONG>glXQueryExtensionsString</STRONG>. The
	  definitions in glx.h can be used at compile time to
	  determine if procedure calls corresponding to	an extension
	  exist	in the library.
	  OpenGL itself	has also been extended.	Refer to <STRONG>glIntro</STRONG> for
	  more information.

     <STRONG>GLX</STRONG> <STRONG>1.1</STRONG> <STRONG>and</STRONG> <STRONG>GLX</STRONG> <STRONG>1.2</STRONG>
	  GLX 1.2 is now supported. It is backward compatible with GLX
	  1.1 and GLX 1.0.

	  GLX 1.2 corresponds to OpenGL	version	1.1 and	introduces the
	  following new	call: <STRONG>glGetCurrentDisplay</STRONG>.

	  GLX 1.1 corresponds to OpenGL	version	1.0 and	introduces the
	  following new	calls:	<STRONG>glXQueryExtensionsString</STRONG>,
	  <STRONG>glXQueryServerString</STRONG>,	and <STRONG>glXGetClientString</STRONG>.

	  Call <STRONG>glQueryVersion</STRONG> to determine at runtime what version of
	  GLX is available. <STRONG>glQueryVersion</STRONG> returns the version that is
	  supported on the connection. Thus if 1.2 is returned,	both
	  the client and server	support	GLX 1.2.  You can also check
	  the GLX version at compile time: GLX_VERSION_1_1 will	be
	  defined in glx.h if GLX 1.1 calls are	supported and
	  GLX_VERSION_1_2 will be defined if GLX 1.2 calls are
	  supported.

     <STRONG>SEE</STRONG> <STRONG>ALSO</STRONG>
	  <STRONG>glIntro</STRONG>, <STRONG>glFinish</STRONG>, <STRONG>glFlush</STRONG>, <STRONG>glXChooseVisual</STRONG>, <STRONG>glXCopyContext</STRONG>,
	  <STRONG>glXCreateContext</STRONG>, <STRONG>glXCreateGLXPixmap</STRONG>,	<STRONG>glXDestroyContext</STRONG>,
	  <STRONG>glXGetClientString</STRONG>, <STRONG>glXGetConfig</STRONG>, <STRONG>glXIsDirect</STRONG>,
	  <STRONG>glXMakeCurrent</STRONG>,
	  <STRONG>glXQueryExtension</STRONG>, <STRONG>glXQueryExtensionsString</STRONG>,
	  <STRONG>glXQueryServerString</STRONG>,	<STRONG>glXQueryVersion</STRONG>, <STRONG>glXSwapBuffers</STRONG>,
	  <STRONG>glXUseXFont</STRONG>, <STRONG>glXWaitGL</STRONG>, <STRONG>glXWaitX</STRONG>, <STRONG>XCreateColormap</STRONG>,
	  <STRONG>XCreateWindow</STRONG>, <STRONG>XSync</STRONG>




















</PRE>
</BODY>
</HTML>
